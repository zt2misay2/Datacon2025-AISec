AppJacking概括了终端内的操作。
为什么这些操作对你很重要?显然,基于检测的保护远非完美。行为工具依赖于模式匹配检测数据来确定应用程序的操作是否合法或恶意。统计置信度的高低决定了所有差异。聪明的攻击者知道这一点,并通过增加额外的行为和对象以及阶段之间的延迟来降低统计置信度。最好的情况是,这意味着三级分析师需要分析和调查更多的警报,IT-Ops也需要清理混乱。最坏的情况是,检测完全被避开。然而,如果这些AppJacking操作不被允许,那么攻击就可以在不需要检测(即识别)的情况下被击败,这就是我们总结它们的原因。
AppJacking执行以下概括的操作:
- 将文件下载到磁盘:而不是让被劫持的应用程序自己执行所有需要的恶意指令,而是下载并运行其他东西来完成这些操作。
- 启动/加载磁盘上的文件。
- 修改磁盘上已有的关键系统或应用程序文件。
- 修改合法内容以获得优势。
- 确保恶意软件在主机重启时启动。
- 读取/窃取操作系统或其他应用程序内存中的数据。
- 窃取凭据和/或有价值的数据。
- 将恶意指令注入另一个应用程序的内存:通过填充大量恶意指令,将相同或另一个应用程序变成黑客工具。
- 某些应用程序(如Chrome)比其他应用程序受到更多监控,使用Chrome劫持另一个较少监控的应用程序来执行大部分恶意操作可以更加隐蔽。
- 将恶意库加载到另一个应用程序的内存中。
- 添加/修改注册表键:确保恶意软件在主机重启时启动。
- 禁用选定的安全控制。
- 启动并使用操作系统实用程序:磁盘上的恶意文件可能会被检测到,操作系统实用程序可以做恶意文件本来会做的事情。
- 启动/使用无文件进程:磁盘上的恶意文件可能会被检测到,或者无法写入磁盘,可以向这些进程中加载大量的恶意指令。
- 接收并执行来自远程对手的命令:人工控制的操作可以根据终端进行调整,远程使用Cobalt Strike等工具。
- 传输被盗数据:中国就是通过这种方式窃取了数万亿美元的知识产权。
上表并不旨在包罗万象。理想情况下,应用零信任原则可以缓解AppJacking风险。上面“AppJacking操作”表中的每一行都描述了被劫持的应用程序用于对企业造成伤害的不同方式。应用零信任意味着使用安全控制来阻止这些操作。这种方法的好处在于不必确定什么是异常或恶意的。不需要检测!结果是在端点被攻破之前,在生成检测警报之前,在三级EDR分析师必须调查之前,提供实时保护。
不幸的是,大多数EPP代理缺乏这些功能,或者它们拥有的功能过于繁琐。
端点保护代理对AppJacking的缓解
下表描述了不同通用EPP功能及其可能或不可能缓解AppJacking风险的方式。稍后,我们将看看它们在零信任原则方面能做什么和不能做什么。
EPP功能
- 补丁管理:不再被认为是标准的EPP功能;消除或屏蔽软件漏洞,使应用程序无法被利用;不能缓解其他两种AppJacking方法(即设计缺陷、代码注入)
- 反利用:将代码注入应用程序,力求防止通过漏洞利用进行的AppJacking;一旦应用程序被劫持则不起作用;没有已知的实际贡献的实证证据;一些分析师质疑其在野外是否真的有效
- 签名检测:如果在加载到目标应用程序内存之前识别出恶意文件,则可以防止AppJacking;文件操纵以逃避检测非常容易,因此这很少能防止AppJacking
- 机器学习文件检测:分析文件中的恶意指令,如果检测到恶意则防止AppJacking;使用多种混淆技术来逃避检测;一些EPP将文件上传到云端进行分析,但由于隐私和数据泄露问题,不会对潜在的武器化文档进行此类操作
- 应用程序控制:仅应用了一些零信任原则;所有实现都具有预启动功能,但很少有后启动功能;预启动阻止可执行文件、脚本和库文件的启动/加载,这些文件可以执行复杂的有害操作;后启动(也称作peri启动)限制应用程序的文件/文件夹读写操作;由于复杂性,不到0.1%的企业使用此功能
- 行为检测(也称作EDR):使用机器学习和启发式方法检测恶意行为;如果检测具有高统计置信度,则在毫秒内终止进程并将文件隔离;当检测的统计置信度较低时,会为三级分析师生成警报以进行调查和响应,而AppJacking操作则继续进行;如果警报被证实有效,有时会有自动清理,有时需要手动清理;谷歌的Project Zero在其许多零日漏洞利用分析中说,“这类漏洞利用很可能很难通用检测”,或者他们不对检测提出建议
当恶意软件成为新闻头条时,我们常被问及如果安装了AppGuard的终端遇到这种恶意软件可能会有什么结果。以最近报道的一种名为Mallox的勒索软件为例,我们看到的第一份第三方报告包含了所有我们需要的信息,可以肯定地说AppGuard能够使用默认策略轻松阻止此类攻击。这篇博客将向读者介绍AppGuard如何进行这些评估的概念,而不深入技术细节。通过阅读,读者将更好地理解基于恶意软件检测的防御与AppGuard通过控制阻止恶意软件技术活动之间的区别,而无需检测和识别恶意软件本身。
为什么大多数恶意软件分析缺乏关键信息?世界主要由基于检测的终端保护工具主导。它们只有在识别出攻击主机的恶意软件的某些特征时才能成功。必须成功匹配某种模式。防病毒软件以其签名(又称哈希校验和)而闻名。还有许多其他瞬息万变的模式,包括文件、通信、行为等。这些几乎随着每次攻击变种而变化。因此,检测工具面临解析坏与好之间无限可能性的挑战。基于控制的工具既不检测也不模式匹配。所有这些都是阻止恶意软件技术活动,无论供应商是否意识到这一点。恶意软件进入终端并不能实现其目标;要做到这一点,恶意软件必须成功完成一系列操作。基于控制的终端保护工具(例如AppGuard)努力阻止这些操作。
AppGuard在终端内应用零信任原则。这意味着AppGuard假设最终会有不好的东西进入终端。AppGuard的答案是不让恶意软件做它需要做的事情。通常阻止一个动作就足以击败整个恶意软件攻击。这不需要识别文件、IP地址或行为模式,这些是检测工具所追求的瞬息万变的东西。由恶意软件检测供应商撰写的恶意软件分析往往花费大量篇幅来识别写入磁盘的文件、添加的注册表项或访问的域名/IP,而不是执行这些操作的应用程序(即进程)。
阻止恶意软件所需的“必要知识”:执行者、目标、动作 (ATA)。每个恶意软件攻击都包含一个攻击树,该攻击树由一个或多个恶意软件技术组成,而这些技术又由执行者(例如应用程序进程)对目标执行的一个或多个动作组成。例如,考虑涉及Google Chrome的零日漏洞利用攻击,其中Chrome消耗了一些“坏”的东西。然后,恶意指令由Chrome(执行者)执行,导致Chrome可能将(动作)一个可执行文件写入“下载”文件夹,并启动这个可执行文件(另一个动作)。实际上这里有两个ATA:1) Chrome(执行者)将(动作)一个可执行文件写入磁盘(目标);2) Chrome(执行者)启动(动作)位于“下载”文件夹中的文件(目标)。这是攻击树的一个分支产生另一个分支。假设Chrome还将脚本文件写入另一个位置,以及另一个文件(例如DLL)写入另一个位置。由于所有这些都旨在执行恶意活动,每个都会被描绘为从Chrome衍生出来的分支。根据它们的作用,每个都可以衍生出其他分支,再衍生出更多的分支。最终,攻击由许多分支组成的树构成。每个分支由执行者、目标和动作(ATA)组成。
查看ATA以预测基于控制的保护结果。在查看Mallox之前,让我们从AppGuard控制的角度完成这个Chrome示例。AppGuard会允许Chrome将第一个文件写入“下载”文件夹,因为如果用户不能将文件写入用户文件夹,Chrome就毫无用处。这个分支会产生另一个分支,其中Chrome触发位于“下载”文件夹中的这个可执行文件的启动。AppGuard不会允许这个启动,因为它禁止从未受信任的发布者数字签名的高风险文件夹(如“下载”)中启动任何东西。这部分攻击被AppGuard阻止。接下来,第二个文件是一个脚本文件,如PowerShell,位于另一个高风险用户文件夹(如桌面)。AppGuard不会允许PowerShell加载这个脚本文件,因为它的位置在高风险文件夹中。这部分攻击被AppGuard阻止。最后,第三个文件是一个动态链接库,Chrome被指示将其写入Chrome应用程序本身的同一文件夹中。AppGuard不会允许Chrome将此文件写入该位置,因为AppGuard“限制”了Chrome等高风险应用程序,限制了Chrome可以读取和写入的位置和内容。这部分攻击被AppGuard阻止。由于这是最后一个分支,整个攻击已被阻止。而且,AppGuard在没有识别恶意软件攻击本身的情况下就阻止了这一切。
AppJacking是指攻击者通过各种方式控制终端上的应用程序,并利用这些被控制的应用程序对企业造成伤害。常见的网络安全组件难以应对AppJacking,这种攻击通常表现为零日攻击、由于缺少补丁导致的入侵、武器化文档、路过式下载、代码注入等。引入这一术语的原因在于,无论应用程序是如何被劫持的,它都有助于非技术人员更好地理解问题。现在企业必须允许其应用程序执行某些操作,这可能让一些人感到惊讶,因为这些操作可以用非常非技术化的语言来描述。
博客摘要
- AppJacking是如何发生的
- 表:AppJacking方法
- 这些应用程序可能在2021年对您的企业造成了危害
- AppJacking:概括终端内的操作
- 表:AppJacking操作(即,防御应该阻止的概念)
- 理想情况下,应用零信任原则可以缓解AppJacking风险
- 端点保护代理对AppJacking的缓解
- 表:EPP功能(即,它们针对AppJacking的作用)
- 零信任原则与通用端点保护机制
- 表:AppJacking的涵盖/遗漏的零信任原则
- 行为检测(又称EDR)不是零信任机制
- 在端点内添加零信任到网络安全防御对于缓解AppJacking风险和降低劳动力成本至关重要
- 隔离看起来很好但很少部署,因为大多数实现都非常痛苦
- AppGuard提供了企业所需的零信任能力以补充检测防御
- 与其他方案相比,AppGuard的操作工作量较小
- 表:更多关于AppGuard如何缓解AppJacking风险的细节