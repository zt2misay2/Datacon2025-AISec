AppJacking是指攻击者通过各种方式控制终端上的应用程序，并利用这些被控制的应用程序对企业造成伤害。常见的网络安全组件难以应对AppJacking，这种攻击通常表现为零日攻击、由于缺少补丁导致的入侵、武器化文档、路过式下载、代码注入等。引入这一术语的原因在于，无论应用程序是如何被劫持的，它都有助于非技术人员更好地理解问题。现在企业必须允许其应用程序执行某些操作，这可能让一些人感到惊讶，因为这些操作可以用非常非技术化的语言来描述。
AppJacking是如何发生的
应用程序是在终端上执行一系列指令的过程，这些指令实现了我们使用的所有功能。AppJacking发生时，你的应用程序开始执行对手的指令。从概念上讲，我们可以将应用程序劫持的方法分为三类。读者不需要完全理解这些方法也能继续阅读本文。
AppJacking方法
- 漏洞利用：源代码中的编程错误被利用，使得恶意指令由应用程序执行。这是补丁管理的重要原因。
- 设计缺陷：应用程序供应商未能考虑或预见其应用程序的设计如何被对手用来执行恶意指令。例如，一些比例的武器化文档攻击利用了Microsoft Office的设计，使用合法的宏和脚本引擎功能来造成伤害。
- 注入：将恶意指令写入内存或通过恶意库文件加载到内存中，无需目标应用程序有任何缺陷。
这些应用程序可能在2021年对您的企业造成了危害
以下是由Google的“Project Zero”报告的一份野外发现的漏洞列表。这份清单并不包括所有应用程序零日漏洞，也不是整个网络安全社区观察到的所有野外零日攻击的汇总。
- Google Chrome - CVE-2021-21148
- Adobe Reader - CVE-2021-21017
- Google Chrome - CVE-2021-21166
- Microsoft Exchange Server - CVE-2021-26855
- Microsoft Exchange Server - CVE-2021-26857
- Microsoft Exchange Server - CVE-2021-26858
- Microsoft Exchange Server - CVE-2021-27065
- Microsoft Internet Explorer - CVE-2021-26411
- Google Chrome - CVE-2021-21166
- Microsoft Internet Explorer - CVE-2021-26411
- Google Chrome - CVE-2021-21193
- Google Chrome - CVE-2021-21220
- Adobe Reader - CVE-2021-21220 {并非拼写错误}
- Microsoft Internet Explorer - CVE-2021-33742
- Google Chrome - CVE-2021-30551
- Google Chrome - CVE-2021-30554
- Microsoft Internet Explorer - CVE-2021-34448
- Google Chrome - CVE-2021-30563
- Microsoft Internet Explorer - CVE-2021-40444
- Google Chrome - CVE-2021-30632
- Google Chrome - CVE-2021-30633
- Google Chrome - CVE-2021-37973
- Google Chrome - CVE-2021-37975
- Google Chrome - CVE-2021-37976
只能应用一些零信任原则来限制被隔离应用程序在多个维度（如文件、注册表、内存、子进程、权限和网络）上的读写操作。微软的应用程序防护是唯一具备此功能的端点保护平台（EPP）产品，并免费提供给所有Windows企业许可证持有者，但使用率不到1%。企业也可以从其他供应商处购买各种实现。
将零信任原则应用于高风险应用程序意味着不允许它们执行潜在恶意操作。这些操作与企业网络安全堆栈中可能拥有的四种类型工具的关系如下所示。应用程序控制分为预执行和后执行（也称作peri执行），因为很少有应用程序控制工具支持后执行，那些支持后执行的工具被认为太难使用。尽管如此，我们可以看到每种工具对高风险应用程序可能应用的零信任缓解措施。
涵盖/遗漏的零信任原则：
- 应用程序控制（预执行）
- 应用程序控制（后执行）
- 行为检测（EDR）
- 隔离
将文件下载到磁盘：否、是、否、是
启动/加载磁盘上的文件：是、否、可能、否
修改磁盘上已有的关键系统或应用程序文件：否、是、可能、是
读取/窃取操作系统或其他应用程序内存中的数据：否、否、可能、是
将恶意指令注入另一个应用程序的内存：否、否、可能、是
将恶意库加载到另一个应用程序的内存：是、否、可能、是
添加/修改注册表键：否、是、可能、是
启动并使用操作系统实用程序：是、否、可能、是
启动/使用无文件进程：否、是、可能、是
接收并执行来自远程对手的命令：否、否、可能、是
传输被盗数据：否、否、否、是
行为检测（也称作EDR）不是零信任机制。许多“可能”答案需要解释。一个AppJacking攻击可能涉及十个阶段。如果在第三阶段发生检测，并且该检测具有高统计置信度，那么行为检测代理将在一秒钟内终止攻击中识别的所有进程。这可能发生在第四到第六阶段之前，这意味着第七到第十阶段永远不会发生。预防第七到第十阶段可能相当于上表中会被阻止的一个或多个行。但这些都是反应而非零信任拒绝。行为检测代理不会明确阻止第七到第十行的动作。相反，终止相关进程会导致这些原本会发生的行为被终止。从默认拒绝的角度来看，行为检测不是零信任机制。零信任机制本质上是确定性的：允许/拒绝特定动作。
在端点内添加零信任到网络安全防御对于缓解AppJacking风险和降低劳动力成本至关重要。优秀的医疗保健包括预防措施，如疫苗以避免感染，以及早期检测方法以治疗疾病。企业的网络安全防御也是如此，两者结合更好。检测工具可以击败可识别的恶意软件攻击。零信任工具不是通过识别恶意软件，而是通过阻止其有害行为来击败攻击。一种工具可以阻止另一种工具错过的，或者比另一种工具更早地阻止。这是优秀的网络安全防御。
通过零信任工具阻止检测工具错过的内容，并在检测工具反应之前阻止一些可检测的攻击，添加一个在端点内应用零信任的工具可以减少网络安全堆栈中多个检测工具的警报数量，从而减轻相应网络安全团队的工作负担。此外，端点内的零信任控制在实时阻止攻击，这通常发生在端点被攻破之前。这样的工具可以在检测工具在端点被攻破后做出反应时减轻那些必须修复端点的人的工作负担。
隔离看起来很好但很少部署，因为大多数实现都非常痛苦。这个话题值得单独一篇博客文章。简而言之，有几种不同的隔离工具。主机沙箱不同于网络或云沙箱，它是一个垃圾场，几年前就被企业端点移除了。微软提供的“应用程序防护”采用了进程虚拟化。这要求修改应用程序源代码，以便应用程序能够穿透边界在整个端点上工作。很少有应用程序经过这样的修改。“应用程序防护”随Windows企业许可证免费提供，但不到1%的企业选择使用它。Bromium基于驱动的隔离工具也遭受了与主机沙箱相同的命运。几乎没有EPP包含隔离功能。必须从第三方获取这些功能。
AppGuard提供了企业所需以补充检测防御的零信任能力。AppGuard结合了“隔离”和“预执行应用程序控制”，相当于上表中总结的因AppJacking导致的有害操作的所有“是”条目，详细信息见底部表格。
与其他方案相比，AppGuard的操作工作量较小。AppGuard几乎不受过去和现在的应用程序控制或隔离工具的操作困难的影响。AppGuard确实需要一些前期调优，如果受保护主机进行了重大更改，有时后期也需要调优。在策略未强制执行的短暂发现阶段，可以看到一个或少数几个合法应用程序需要进行策略调优。在策略强制执行的第一周或两周内，可能还需要一些额外的调优。根据观察，部署代理中不到1%的策略与供应商指定的默认策略不同，这种调优工作量很小且很短暂。
我们主要关注三类文件：可执行文件、脚本文件和动态链接库（DLL，Windows）。Sec-Ops不希望恶意可执行文件启动，也不希望恶意脚本和DLL文件加载。IT-Ops则希望合法文件能够正常启动或加载。最好的解决方案是添加一个确定性控制来处理那些试图绕过检测的文件。这种控制利用数字签名，代表了在端点内应用的零信任原则，只允许明显可信的文件启动或加载。
为什么应用控制既过于复杂又不足以应对恶意文件？任何应用控制工具都可以限制具有有效、受信任数字签名或哈希值的文件启动和加载。以Zoom和Chrome为例，去年业界观察到这些及其他常见用户应用程序在野外出现了零日漏洞。一旦被允许启动，被利用的应用程序就会进行恶意行为。通过简单的权限提升技术，这些被劫持的应用程序随后可以向系统空间添加或更改文件。大多数应用控制工具，如微软的工具，并不控制应用程序在被允许启动后可以做什么。那些能做到这一点的工具使用起来非常困难，以至于大多数客户只使用启动控制。因此，应用控制工具必须限制整个端点的启动，而不仅仅是高风险文件夹。这意味着“允许”策略列表要比只关注高风险文件夹大100到1000倍，即更多的管理负担和中断合法工作的风险。难怪市场分析师说很少有新的应用控制部署？
AppGuard是解决端点文件夹中恶意文件的更简单、更好的解决方案。它由三个基本控制组成：启动、隔离和隔离。虽然隔离和隔离似乎与端点文件夹中的恶意文件问题无关，但它们的相关性将在稍后解释。AppGuard的启动控制仅应用于高风险文件夹，尽管管理员可以根据需要将其应用于其他文件夹。大多数高风险文件夹已经在AppGuard的默认策略中指定。AppGuard的启动控制不处理不断变化的文件哈希值。相反，AppGuard依赖于受信任发布者的数字签名，这大大简化了“允许”策略。
至于那些被劫持的用户空间应用程序，AppGuard应用了隔离控制。这可以按发布者（即包含由该发布者签名的任何应用程序）、按文件夹（包含文件夹中的任何应用程序）和/或按应用程序应用。例如，一个被隔离的Zoom正常运行，但如果它被劫持，AppGuard不允许它在系统空间中添加或更改文件。通过不让高风险应用程序更改系统空间，大大减少了对所有这些文件夹应用启动控制的必要性。只有少数标准系统空间文件夹需要启动控制，这限制了只允许由选定发布者签名的文件启动。
AppGuard的隔离不仅限于文件系统，还包括Windows注册表、进程内存、子进程、进程权限和网络通信等其他维度。隔离的目的是保护主机免受被隔离内容的影响。隔离是隔离的反面。隔离保护应用程序、文件夹和/或对象免受主机其余部分的影响。AppGuard是分层保护。如果有恶意内容以某种方式不受限制地运行，隔离规则将保护所选文件夹的内容免受主机其余部分的影响。例如，Chrome在磁盘上的文件中缓存密码。一条隔离规则确保只有Chrome可以访问它。
总之，AppGuard提供了最简单、最有效的方法来减轻企业端点文件夹中文件所带来的风险。